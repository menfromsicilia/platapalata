---
description:
globs:
alwaysApply: true
---
You have extensive expertise in Vue 3, Nuxt 3, TypeScript, Node.js, Vite, Vue Router, Pinia, VueUse, PrimeVue, and SCSS. You possess a deep knowledge of best practices and performance optimization techniques across these technologies.

Code Style and Structure
- Write clean, maintainable, and technically accurate TypeScript code.
- Prioritize functional and declarative programming patterns; avoid using classes.
- Emphasize iteration and modularization to follow DRY principles and minimize code duplication.
- Prefer Composition API <script setup> style.
- Use Composables to encapsulate and share reusable client-side logic or state across multiple components in your Nuxt application.
- Structure files: exported component, composables, helpers, static content, types.
- Use descriptive variable names with auxiliary verbs (e.g., isLoading, hasError).

Naming Conventions
- Use lowercase with dashes for directories (e.g., components/auth-wizard).
- Use **PascalCase** for component file names (e.g., components/AuthWizard.vue).
- Utilize composables, naming them as use<MyComposable> in camelCase (e.g., composables/useAuthState.ts).
- Favor named exports for functions to maintain consistency and readability.

Nuxt 3 Specifics
- Nuxt 3 provides auto imports, so there's no need to manually import 'ref', 'computed', 'watch', 'useState', 'useRouter', or 'useFetch'.
- Follow Nuxt 3 directory structure (e.g., pages/, components/, composables/, server/).
- Use Nuxt's built-in features:
  - Auto-imports for components and composables.
  - File-based routing in the pages/ directory.
  - Server routes in the server/ directory.
- For color mode handling, use the built-in '@nuxtjs/color-mode' with the 'useColorMode()' function.
- Take advantage of VueUse functions to enhance reactivity and performance (except for color mode management).
- Use the Server API (within the server/api directory) to handle server-side operations like database interactions, authentication, or processing sensitive data that must remain confidential.
- Use useRuntimeConfig to access and manage runtime configuration variables that differ between environments and are needed both on the server and client sides.
- Use app.config.ts for app theme configuration and non-sensitive application settings.
- For SEO use useHead and useSeoMeta.
- For images use <NuxtImg> or <NuxtPicture> component.
- Leverage Nuxt plugins for global functionality.
- Utilize Nuxt's auto-imports feature for components and composables.

Fetching Data
1. Use useFetch for standard data fetching in components that benefit from SSR, caching, and reactively updating based on URL changes.
2. Use $fetch for client-side requests within event handlers or when SSR optimization is not needed.
3. Use useAsyncData when implementing complex data fetching logic like combining multiple API calls or custom caching and error handling.
4. Set server: false in useFetch or useAsyncData options to fetch data only on the client side, bypassing SSR.
5. Set lazy: true in useFetch or useAsyncData options to defer non-critical data fetching until after the initial render.

TypeScript Usage
- Use TypeScript for all code; prefer types over interfaces.
- Avoid enums; use const objects or maps instead for improved type safety and flexibility.
- Use functional components with TypeScript types.
- Leverage Vue 3 with TypeScript, using defineComponent and PropType when needed.

Syntax and Formatting
- Use arrow functions for methods and computed properties.
- Avoid unnecessary curly braces in conditionals; use concise syntax for simple statements.
- Use template syntax for declarative rendering.

State Management
- Use Pinia for global state management.
- Create stores in the stores/ directory.
- Use the setup store syntax for better TypeScript support and flexibility.
- Leverage Pinia's built-in devtools integration.

UI and Styling
- Use PrimeVue for UI components following its composition and configuration patterns.
- Use SCSS for styling with the <style lang="scss" scoped> syntax.
- Implement responsive design with SCSS mixins and variables; use a mobile-first approach.
- Organize SCSS: use variables for colors, spacing, and breakpoints; create mixins for reusable styles.
- Consider creating a shared styles directory for global SCSS variables, mixins, and functions.

Performance Optimization
- Leverage Nuxt's built-in performance optimizations.
- Use Suspense for asynchronous components when appropriate.
- Implement lazy loading for routes and components.
- Optimize images: use WebP format, include size data, implement lazy loading with <NuxtImg>.
- Optimize Web Vitals (LCP, CLS, FID).
- Use dynamic imports for heavy components or libraries.

Vue 3 and Composition API Best Practices
- Use <script setup> syntax for concise component definitions.
- Leverage ref, reactive, and computed for reactive state management.
- Use provide/inject for dependency injection when appropriate.
- Implement custom composables for reusable logic.
- Avoid unnecessary watchers; prefer computed properties when possible.

Key Conventions
- Use VueUse for common composables and utility functions.
- Follow the principle of single responsibility for components and composables.
- Write self-documenting code with clear naming and structure.
- Use TypeScript strict mode for enhanced type safety.

Follow the official Nuxt.js and Vue.js documentation for up-to-date best practices on Data Fetching, Rendering, and Routing.